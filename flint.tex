\documentclass[a4paper,10pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{eucal}
\usepackage{amscd}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{wrapfig}
\urlstyle{sf}

\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\addtolength{\textwidth}{1.5in}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Pee}{\mathbb{P}}
\newcommand{\EuO}{\mathcal{O}}
\newcommand{\Qbar}{\overline{\mathbb{Q}}}
\newcommand{\fn}{\hfill[Function]}
\newcommand{\macro}{\hfill[Macro]}
\newcommand{\gmp}{\hfill[GMP]}

\newcommand{\ljk}[2]{\left(\frac{#1}{#2}\right)}
\newcommand{\modulo}[1]{\;\left(\mbox{mod}\;#1\right)}
\newcommand{\fr}{\mathfrak}

\def\notdivides{\mathrel{\kern-3pt\not\!\kern4.5pt\bigm|}}
\def\nmid{\notdivides}
\def\nsubseteq{\mathrel{\kern-3pt\not\!\kern2.5pt\subseteq}}

\parindent=0pt
\parskip 4pt plus 2pt minus 2pt

%\email{w.b.hart@maths.warwick.ac.uk}

\title{FLINT: Fast Library for Number Theory}
\author{William B. Hart}

\begin{document}
\maketitle
\lstset{language=c}
\lstset{escapeinside=\%\%}

\section{Introduction}

FLINT is a C library of functions for doing number theory. It is highly optimised and can be compiled on numerous platforms. FLINT also has the aim of providing support for multicore and multiprocessor computer architectures.

FLINT is currently maintained by William Hart of Warwick University in the UK and David Harvey of Harvard University in the US.

As of version 1.0, FLINT compiles on and supports 32 and 64 bit x86 processors, the G5 and Alpha processors.

FLINT is supplied as a set of modules, Z, Zvec, Zpoly, etc., each of which can be linked to a C program that wishes to make use of their functionality. There are some dependencies amongst the modules, and these are listed in the introductions to the relevant modules below.

All of the functions in FLINT have a corresponding test function provided in the appropriately named module in the test directory. E.g: all the functions in Z.c have test functions in Z-test.c.

\newpage
\section{Integer Arithmetic}
\subsection{Introduction}
The module Z provides basic functions for integer arithmetic such as arithmetic operations, factorisation, the Chinese Remaninder Theorem, basic modular arithmetic and so on. 

To make use of functions from the FLINT Z module, simply put the following line in your C program:

\begin{verbatim}#include <Z.h>\end{verbatim}

and ensure that the main FLINT directory is included in your include path, e.g: if FLINT is unpacked in the directory /usr/local/FLINT-1.0/ simply add

\begin{verbatim}-I"/usr/local/FLINT/"\end{verbatim}

to the command line when compiling your program using gcc.

All of the basic functionality of the GNU Multi Precision library (GMP's) mpz module is included in Z. Each mpz function is renamed in FLINT. For example mpz\_add becomes Z\_add in FLINT, etc. The GMP functions are wrapped as macros, so there is no loss of performance in using the corresponding FLINT function. In some cases we transparently replace a GMP function with our own faster native FLINT implementation. All functions which are simply macros for GMP functions will have [GMP] written next to their prototype in the documentation below, whilst all true FLINT functions have [Function]. In some cases functions which are very short are defined as inline functions and occur in the associated .h file for the module. These will have [Macro] written next to them in the documentation below.

In addition to functions offered by GMP, FLINT offers functions for working with unsigned long integer types and a number of other functions not supplied by GMP, such as random primes, the Chinese Remainder Theorem, integer factorisation and the Tonelli-Shanks algorithm for finding square roots modulo a prime and modulo powers of a prime. 

\subsubsection{Reentrancy}
All of the functions implemented in the FLINT Z module are reentrant and thus thread safe and suitable for multicore and multiprocessing hardware.

\subsubsection{Basic Types}
The basic types used by the Z module are \textbf{unsigned long} and \textbf{Z\_t}, a multiple precision integer type which is synonymous with GMP's \textbf{mpz\_t}. As both \textbf{Z\_t} and \textbf{mpz\_t} refer to the same type, there is no performance advantage in working with one as opposed to the other.

All functions accessible in the module Z (which aren't internal only) have their names prefixed by \textbf{Z\_} and those which work exclusively with \textbf{unsigned long}s or \textbf{long}s are suffixed with \textbf{\_long}. 

\subsubsection{Files and Dependencies}
The files included with the Z library are:

\begin{verbatim}Z.c, Z.h
factor.c, factor.h
MPQS.c, MPQS.h
SQUFOF.c, SQUFOF.h\end{verbatim}

The integer factorisation function (in particular the multiple polynomial quadratic sieve (MPQS)), relies on an implementation of the block Lanczos algorithm found in the GF2matrix module.

Integer factorisation also relies on GMP-ECM, which must be installed on your system in order to use the Z\_factorise and Z\_ECM functions.

\subsection{Movement and Assignment Functions}
\begin{lstlisting}
void Z_set(Z_t res, Z_t op)%\gmp%
void Z_set_ui(Z_t res, unsigned long op)%\gmp%
void Z_set_si(Z_t res, signed long op)%\gmp%
\end{lstlisting}
\begin{quote}Set \textbf{res} to \textbf{op} of the given type.\end{quote}

\begin{lstlisting}
void Z_set_d(Z_t res, double op)%\gmp%
void Z_set_q(Z_t res, mpq_t op)%\gmp%
void Z_set_f(Z_t res, mpf_t op)%\gmp%
\end{lstlisting}
\begin{quote}Set \textbf{res} to \textbf{op} of the given type, truncating the value to an integer.\end{quote}

\begin{lstlisting}
int Z_set_str(Z_t res, char *str, int base)%\gmp%
\end{lstlisting}
\begin{quote}Set the value of \textbf{res} from \textbf{str}, a null-terminated C string in the given base. The base may can be specified to be from 2 to 62 or \textbf{base} can be zero, in which case one uses leading characters $0x$ or $0X$ for hexadecimal, $0b$ or $0B$ for binary and $0$ for octal, or none at all, in which case the base is assumed to be decimal.

The numerals 0 to 9 are used first as digits, followed by upper case letters, then by lower case letters, however if the base is below 37, case is ignored.

The function returns 0 if the entrire string parsed and -1 otherwise.\end{quote}

\begin{lstlisting}
void Z_swap(Z_t op1, Z_t op2)%\gmp%
\end{lstlisting}
\begin{quote}Swap \textbf{op1} and \textbf{op2}. Using this function is much faster than using \textbf{Z\_set} and moving the values through a temporary \textbf{Z\_t}.\end{quote}

\subsection{Conversion Functions}
\begin{lstlisting}
unsigned long int Z_get_ui(Z_t op)%\gmp%
signed long int Z_get_si(Z_t op)%\gmp%
double Z_get_d(Z_t op)%\gmp%
double Z_get_d_2exp(signed long *exp, Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Convert \textbf{op} to the specified type. The \textbf{2exp} variant returns a value in the range $0 \le |d| < \frac{1}{2}$ and an exponent $exp$ such that $op = d*2^{exp}$. For both of the floating point functions \textbf{op} is truncated if necessary.\end{quote}

\begin{lstlisting}
char * Z_get_str(char *str, int base, Z_t op)
\end{lstlisting}
\begin{quote}Convert \textbf{op} to a string in the given base and return a pointer to that string. 

If \textbf{str} is NULL, the space for the string and its null terminator is allocated, otherwise \textbf{str} should point to a string of adequate size, including a possible minus sign and null terminator.\end{quote}

\subsection{Arithmetic Functions}
\begin{lstlisting}
void Z_add(Z_t res, Z_t a, Z_t b)%\gmp%
void Z_add_ui(Z_t res, Z_t a, unsigned long int b)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to $a + b$.\end{quote}

\begin{lstlisting}
void Z_sub(Z_t res, Z_t a, Z_t b)%\gmp%
void Z_sub_ui(Z_t res, Z_t a, unsigned long int b)%\gmp%
void Z_ui_sub(Z_t res, unsigned long int a, Z_t b)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to $a - b$.\end{quote} 

\begin{lstlisting}
void Z_mul(Z_t res, Z_t a, Z_t b)%\gmp%
void Z_mul_si(Z_t res, Z_t a, long int b)%\gmp%
void Z_mul_ui(Z_t res, Z_t a, unsigned long int b)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to $a*b$.\end{quote} 

\begin{lstlisting}
void Z_addmul(Z_t res, Z_t a, Z_t b)%\gmp%
void Z_addmul_ui(Z_t res, Z_t a, unsigned long int b)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to $res + a*b$.\end{quote} 

\begin{lstlisting}
void Z_submul(Z_t res, Z_t a, Z_t b)%\gmp%
void Z_submul_ui(Z_t res, Z_t a, unsigned long int b)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to $res - a*b$.\end{quote} 

\begin{lstlisting}
void Z_mul_2exp(Z_t res, Z_t a, unsigned long int exp)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to $a*2^{exp}$.\end{quote} 

\begin{lstlisting}
void Z_neg(Z_t res, Z_t n)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to $-n$.\end{quote} 

\begin{lstlisting}
void Z_abs(Z_t res, Z_t n)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to the absolute value of $n$.\end{quote} 

\subsection{Division Functions}
\begin{lstlisting}
void Z_cdiv_q(Z_t q, Z_t n, Z_t d)%\gmp%
void Z_cdiv_r(Z_t r, Z_t n, Z_t d)%\gmp%
void Z_cdiv_qr(Z_t q, Z_t r, Z_t n, Z_t d)%\gmp%
unsigned long int Z_cdiv_q_ui(Z_t q, Z_t n,%\gmp% 
        unsigned long int d)
unsigned long int Z_cdiv_r_ui(Z_t r, Z_t n,%\gmp% 
        unsigned long int d)
unsigned long int Z_cdiv_qr_ui(Z_t q, Z_t r, Z_t n,%\gmp%
        unsigned long int d)
unsigned long int Z_cdiv_ui(Z_t n, unsigned long int d)%\gmp%
void Z_cdiv_q_2exp(Z_t q, Z_t n, unsigned long int exp)%\gmp%
void Z_cdiv_r_2exp(Z_t r, Z_t n, unsigned long int exp)%\gmp%
\end{lstlisting}

\begin{lstlisting}
void Z_fdiv_q(Z_t q, Z_t n, Z_t d)%\gmp%
void Z_fdiv_r(Z_t r, Z_t n, Z_t d)%\gmp%
void Z_fdiv_qr(Z_t q, Z_t r, Z_t n, Z_t d)%\gmp%
unsigned long int Z_fdiv_q_ui(Z_t q, Z_t n,%\gmp% 
        unsigned long int d)
unsigned long int Z_fdiv_r_ui(Z_t r, Z_t n,%\gmp% 
        unsigned long int d)
unsigned long int Z_fdiv_qr_ui(Z_t q, Z_t r, Z_t n,%\gmp%
        unsigned long int d)
unsigned long int Z_fdiv_ui(Z_t n, unsigned long int d)%\gmp%
void Z_fdiv_q_2exp(Z_t q, Z_t n, unsigned long int exp)%\gmp%
void Z_fdiv_r_2exp(Z_t r, Z_t n, unsigned long int exp)%\gmp%
\end{lstlisting}

\begin{lstlisting}
void Z_tdiv_q(Z_t q, Z_t n, Z_t d)%\gmp%
void Z_tdiv_r(Z_t r, Z_t n, Z_t d)%\gmp%
void Z_tdiv_qr(Z_t q, Z_t r, Z_t n, Z_t d)%\gmp%
unsigned long int Z_tdiv_q_ui(Z_t q, Z_t n,%\gmp% 
        unsigned long int d)
unsigned long int Z_tdiv_r_ui(Z_t r, Z_t n,%\gmp% 
        unsigned long int d)
unsigned long int Z_tdiv_qr_ui(Z_t q, Z_t r, Z_t n,%\gmp%
        unsigned long int d)
unsigned long int Z_tdiv_ui(Z_t n, unsigned long int d)%\gmp%
void Z_tdiv_q_2exp(Z_t q, Z_t n, unsigned long int exp)%\gmp%
void Z_tdiv_r_2exp(Z_t r, Z_t n, unsigned long int exp)%\gmp%
\end{lstlisting}
\begin{quote}Divide $n$ by $d$ and set $q$ to the quotient and/or $r$ to the remainder. The functions called \textbf{cdiv} round up to $+\infty$, those called \textbf{fdiv} round down to $-\infty$ and those called $\textbf{tdiv}$ truncate the result. For the \textbf{ui} variants, the return value of the function is the remainder, or in the case of \textbf{cdiv} and \textbf{tdiv}, the absolute value of the remainder. For the \textbf{2exp} variants, the divisor is $2^{exp}$. The \textbf{fdiv\_q\_2exp} and \textbf{fdiv\_r\_2exp} variants can be viewed as a right shift and left truncate respectively.\end{quote}

\begin{lstlisting}
void Z_divexact(Z_t q, Z_t n, Z_t d)%\gmp%
void Z_divexact_ui(Z_t q, Z_t n, unsigned long d)%\gmp%
\end{lstlisting}
\begin{quote}Divide $n$ by $d$ assuming $n$ is a multiple of $d$. The result is undefined if this is not the case.\end{quote}

\subsection{Exponentiation}
\begin{lstlisting}
unsigned long Z_pow_long(unsigned long a, unsigned long exp)%\fn%
\end{lstlisting}
\begin{quote}Returns $a^{exp}$.\end{quote}

\begin{lstlisting}
void Z_pow_ui(Z_t res, Z_t base, unsigned long exp)%\gmp%
void Z_ui_pow_ui(Z_t res, unsigned long base, unsigned long exp)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to $base^{exp}$. The case $0^0$ yields $1$.\end{quote}

\subsection{Modulo Arithmetic}
\begin{lstlisting}
void Z_mod(Z_t res, Z_t n, Z_t d)%\gmp%
unsigned long int Z_mod_ui(Z_t res, Z_t n, unsigned long int d)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to $n$ modulo $d$. The \textbf{ui} variation returns $n \pmod{d}$.\end{quote}

\begin{lstlisting}
void Z_mulmod(Z_t res, Z_t a, Z_t b, Z_t p)%\fn%
unsigned long Z_mulmod_ui(Z_t res, Z_t a, Z_t b, unsigned long p)%\fn%
\end{lstlisting}
\begin{quote}Sets $res$ to $a*b \pmod{p}$. \textbf{Z\_mulmod} assumes that $res$ is not $p$.\end{quote}

\begin{lstlisting}
void Z_mulmod2(mpz_t res, mpz_t a, mpz_t b, mpz_t p)%\macro%
\end{lstlisting}
\begin{quote}Sets $res$ to $a*b \pmod{p}$. This is a more efficient version of multiplication modulo $p$ which assumes that $a$ and $b$ are not (much) bigger than $p$ and that $res$ is not $p$.\end{quote}

\begin{lstlisting}
int Z_congruent_p(Z_t n, Z_t c, Z_t d)%\gmp%
int Z_congruent_ui_p(Z_t n, unsigned long int c,%\gmp%
unsigned long int d)
int Z_congruent_2exp_p(Z_t n, Z_t c, unsigned long int exp)%\gmp%
\end{lstlisting}
\begin{quote}Returns non-zero if $n \equiv c \pmod{d}$ or in the case of $d = 0$ return non-zero if $n = c$. In the case of the \textbf{2exp} variation, $d$ is taken to be $2^{exp}$.\end{quote}

\begin{lstlisting}
int Z_divisible_p(Z_t n, Z_t d)%\gmp%
int Z_divisible_ui_p(Z_t n, unsigned long d)%\gmp%
int Z_divisible_2exp_p(Z_t n, unsigned long exp)%\gmp%
\end{lstlisting}
\begin{quote}Returns non-zero if $n$ is a multiple of $d$. For the \textbf{2exp} variant, $d$ is taken to be $2^{exp}$. It is permitted to have $d = 0$ and only $0$ is considered to be a multiple of $0$.\end{quote}

\begin{lstlisting}
long Z_powm_long(long a, long exp, long p)%\fn%
\end{lstlisting}
\begin{quote}Returns $a^{exp} \pmod{p}$. The magnitude of $a$ is assumed to be not (much) greater than that of $p$. Both $a$ and $exp$ are allowed to be negative.\end{quote}

\begin{lstlisting}
void Z_powm(Z_t res, Z_t base, Z_t exp, Z_t mod)%\gmp%
void Z_powm_ui(Z_t res, Z_t base, unsigned long exp, Z_t mod)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to $base^{exp}$ modulo the given modulus. Negative exponents are allowed for invertible bases, otherwise a divide by zero occurs.\end{quote}

\begin{lstlisting}
unsigned long Z_invert_long(unsigned long a, unsigned long p)%\fn%
\end{lstlisting}
\begin{quote}Returns the inverse of $a$ modulo $p$. The caller must ensure that gcd$(a,p) = 1$.\end{quote}

\begin{lstlisting}
int Z_invert(Z_t res, Z_t a, Z_t p)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to the inverse of $a$ modulo $p$ if it exists and returns a non-zero value, otherwise the return value is zero and $res$ is undefined.\end{quote}

\begin{lstlisting}
int Z_sqrtmod(Z_t res, Z_t a, Z_t p)%\fn%
\end{lstlisting}
\begin{quote}Sets $res$ to a square root of $a$ modulo $p$ and returns 1, otherwise if $a$ is not a square modulo $p$, the return value of the function will be zero. No test is performed to check that $p$ is a prime. The caller must ensure this.\end{quote}

\begin{lstlisting}
void Z_sqrtmodpklift(Z_t res, Z_t z, Z_t a, Z_t pk)%\fn%
\end{lstlisting}
\begin{quote}Sets $res$ to a square root of $a$ modulo $p^k$ given $z$ has been set to a square root of $a$ modulo $p^{k-1}$.\end{quote}

\begin{lstlisting}
int Z_sqrtmodptopk(Z_t res, Z_t sqrt, Z_t a, Z_t p, int k)%\fn%
\end{lstlisting}
\begin{quote}Sets $res$ to a square root of $a$ modulo $p^k$ given that $z$ has been set to a square root of $a$ modulo$p$.\end{quote}

\begin{lstlisting}
int Z_sqrtmodpk(Z_t res, Z_t a, Z_t p)%\fn%
\end{lstlisting}
\begin{quote}Sets $res$ to a square root of $a$ modulo $p^k$ and returns 1, or returns 0 if $a$ is not a square modulo $p$. The function assumes that $p$ is a prime and the caller must ensure this.\end{quote}

\begin{lstlisting}
void Z_CRT(Z_t res, Z_t n, Z_t x1, Z_t x2, Z_t n1, Z_t n2)%\fn%
\end{lstlisting}
\begin{quote}Sets $n = n1*n2$ and $res$ to the unique value modulo $n$ such that $res \equiv x1 \pmod{n1}$ and $res \equiv x \pmod{n2}$.\end{quote}

\subsection{Root Extraction Functions}
\begin{lstlisting}
int Z_root(Z_t res, Z_t op, unsigned long n)
\end{lstlisting}
\begin{quote}Set $res$ to the integer part of the $n$-th root of $op$. Return a non-zero value if the computation resulted in an exact root.\end{quote}

\begin{lstlisting}
void Z_rootrem(Z_t root, Z_t rem, Z_t op, unsigned long n)%\gmp%
\end{lstlisting}
\begin{quote}Set $root$ to the integer part of the $n$-th root of $op$ and $rem$ to the remainder.\end{quote}

\begin{lstlisting}
void Z_sqrt(Z_t rop, Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Set $rop$ to the integer part of the square root of $op$.\end{quote}

\begin{lstlisting}
void Z_sqrtrem(Z_t rop, Z_t rem, Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Set $rop$ to the integer part of the square root of $op$ and $rem$ to the remainder.\end{quote}

\begin{lstlisting}
int Z_perfect_power_p(Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Return non-zero if $op$ is a perfect power. Negative values of $op$ are accepted.\end{quote}

\begin{lstlisting}
int Z_perfect_square_p(Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Return non-zero if $op$ is a perfect square.\end{quote}

\subsection{Number Theoretical Functions}
\begin{lstlisting}
unsigned long Z_nextprime_long(unsigned long n)%\fn%
\end{lstlisting}
\begin{quote}Returns the next prime after $n$. The function does not check if the result is too large to fit in an unsigned long.\end{quote}

\begin{lstlisting}
void Z_nextprime(Z_t res, Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to the next probable prime greater than $op$.\end{quote}

\begin{lstlisting}
void Z_randomprime(Z_t res, unsigned long bitsize)%\fn%
\end{lstlisting}
\begin{quote}Sets $res$ to a random probable prime up to the given size in bits.\end{quote}

\begin{lstlisting}
int Z_probab_prime_p(Z_t n, int reps)%\gmp%
\end{lstlisting}
\begin{quote}Returns non-zero if $n$ is probably prime, after performing $reps$ rounds of the Miller-Rabin test. The function returns $0$ if the number is definitely composite, $2$ if it is definitely prime and $1$ if it is probably prime. Sensible values of $reps$ lie between about 5 and 10.\end{quote}

\begin{lstlisting}
long Z_extgcd_long(long* a, long* b, long x, long y)%\fn%
\end{lstlisting}
\begin{quote}Returns the greatest common divisor of $x$ and $y$ and sets $a$ and $b$ so that $ax + by = \;\mbox{gcd}(x,y)$.\end{quote}

\begin{lstlisting}
unsigned long Z_gcd_long(long x, long y)%\fn%
\end{lstlisting}
\begin{quote}Returns the greatest common divisor of $x$ and $y$.\end{quote}

\begin{lstlisting}
void Z_gcd(Z_t res, Z_t op1, Z_t op2)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to the (positive) greatest common divisor of $op1$ and $op2$.\end{quote}

\begin{lstlisting}
unsigned long Z_gcd_ui(Z_t res, Z_t op1, unsigned long op2)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to the (positive) greatest common divisor of $op1$ and $op2$ if $res$ is not NULL. If $op2$ is non-zero, the greatest common divisor will fit in an \textbf{unsigned long}, and thus it will be returned by the function, otherwise zero will be returned.\end{quote}

\begin{lstlisting}
void Z_gcdext(Z_t g, Z_t s, Z_t t, Z_t a, Z_t b)%\gmp%
\end{lstlisting}
\begin{quote}Set $g$ to the (positive) greatest common divisor of $a$ and $b$ and set $s$ and $t$ so that $g = as + bt$. If $t$ is null, then it is not computed.\end{quote}

\begin{lstlisting}
void Z_lcm(Z_t res, Z_t op1, Z_t op2)%\gmp%
void Z_lcm_ui(Z_t res, Z_t op1, unsigned long op2)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to the lowest common multiple of $op1$ and $op2$. The result will always be positive or zero.\end{quote}

\begin{lstlisting}
int Z_legendre(Z_t a, Z_t p)%\gmp%
\end{lstlisting}
\begin{quote}Compute the Legendre symbol $\ljk{a}{p}$. This is defined only for an odd positive prime.\end{quote}

\begin{lstlisting}
int Z_jacobi(Z_t a, Z_t b)%\gmp%
\end{lstlisting}
\begin{quote}Compute the Jacobi symbol $\ljk{a}{b}$. This is defined for odd $b$, and coincides with the Legendre symbol when $b$ is an odd positive prime.\end{quote}

\begin{lstlisting}
int Z_kronecker(Z_t a, Z_t b)%\gmp%
int Z_kronecker_si(Z_t a, long b)%\gmp%
int Z_kronecker_ui(Z_t a, unsigned long b)%\gmp%
int Z_si_kronecker(long a, Z_t b)%\gmp%
int Z_ui_kronecker(unsigned long a, Z_t b)%\gmp%
\end{lstlisting}
\begin{quote}Compute the Kronecker symbol $\ljk{a}{b}$. This coincides with the Jacobi symbol when $b$ is odd. It is defined such that $\ljk{a}{2} = \ljk{2}{a}$ when $a$ is odd, or 0 if $a$ is even.\end{quote}

\begin{lstlisting}
unsigned long Z_remove(Z_t res, Z_t op, Z_t n)%\gmp%
\end{lstlisting}
\begin{quote}Remove all occurrences of the factor $n$ (if any) from $op$ and set $res$ to the result. The function returns the number of occurrences actually removed. This function is much more efficient for removing powers of factors than removing them one at a time.\end{quote}

\begin{lstlisting}
void Z_fac_ui(Z_t res, unsigned long int op)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to the factorial of $op$.\end{quote}

\begin{lstlisting}
void Z_bin_ui(Z_t res, Z_t n, unsigned long k)%\gmp%
void Z_bin_uiui(Z_t res, unsigned long n, unsigned long k)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to the binomial coefficient $\left(\begin{array}{c}n \\ k\end{array}\right)$. Negative values of $n$ are supported.\end{quote}

\begin{lstlisting}
void Z_fib_ui(Z_t fn, unsigned long n)%\gmp%
void Z_fib2_ui(Z_t fn, Z_t fnsub1, unsigned long n)\end{lstlisting}
\begin{quote}Set $fn$ to the $n$-th Fibonacci number $F_n$. The second variant also sets $fnsub1$ to $F_{n-1}$. These functions are efficient for calculating individual Fibonacci numbers. The usual recursion formula should be used to compute sequences of Fibonacci numbers.\end{quote}

\begin{lstlisting}
void Z_lucnum_ui(Z_t ln, unsigned long n)%\gmp%
void Z_lucnum2_ui(Z_t ln, Z_t lnsub1, unsigned long n)%\gmp%
\end{lstlisting}
\begin{quote}Set $ln$ to the $n$-th Lucas number $L_n$. The second variant also computes $L_{n-1}$. The usual recursion should be used to compute sequences of Lucas numbers. These functions are efficient only for computing individual Lucas numbers.\end{quote}

\subsection{Comparison Functions}
\begin{lstlisting}
int Z_cmp(Z_t op1, Z_t op2)%\gmp%
int Z_cmp_d(Z_t op1, double op2)%\gmp%
int Z_cmp_si(Z_t op1, signed long op2)%\gmp%
int Z_cmp_ui(Z_t op1, unsigned long op2)%\gmp%
\end{lstlisting}
\begin{quote}Compare $op1$ and $op2$. Return a positive value if $op1 > op2$, $0$ if they are equal and a negative value otherwise.\end{quote}

\begin{lstlisting}
int Z_cmpabs(Z_t op1, Z_t op2)%\gmp%
int Z_cmpabs_d(Z_t op1, double op2)%\gmp%
int Z_cmpabs_ui(Z_t op1, unsigned long op2)%\gmp%
\end{lstlisting}
\begin{quote}The same as for the comparison functions above, except that the absolute values of $op1$ and $op2$ are compared.\end{quote}

\begin{lstlisting}
int Z_sgn(Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Return a positive value if the sign of $op$ is positive, $0$ if $op$ is zero and a negative value otherwise.\end{quote}

\subsection{Logical and Bit Manipulation Functions}
\begin{lstlisting}
void Z_and(Z_t res, Z_t op1, Z_t op2)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to the bitwise and of $op1$ and $op2$.\end{quote}

\begin{lstlisting}
void Z_ior(Z_t res, Z_t op1, Z_t op2)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to the bitwise inclusive or of $op1$ and $op2$.\end{quote}

\begin{lstlisting}
void Z_xor(Z_t res, Z_t op1, Z_t op2)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to the bitwise exclusive or of $op1$ and $op2$.\end{quote}

\begin{lstlisting}
void Z_com(Z_t res, Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Set $res$ to the one's complement of $op$.\end{quote}

\begin{lstlisting}
unsigned long Z_popcount(Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}If $op \ge 0$, returns the number of 1's in the binary representation of $op$. If $op$ is negative the return value is ULONG\_MAX.\end{quote}

\begin{lstlisting}
unsigned long Z_hamdist(Z_t op1, Z_t op2)%\gmp%
\end{lstlisting}
\begin{quote}If $op1$ and $op2$ are both greater than or equal to zero, or both are negative, this function returns the number of binary bits where they differ. If one is greater than or equal to zero and the other is less than zero, ULONG\_MAX is returned.\end{quote}

\begin{lstlisting}
unsigned long Z_scan0(Z_t op, unsigned long starting_bit)%\gmp%
unsigned long Z_scan1(Z_t op, unsigned long starting_bit)%\gmp%
\end{lstlisting}
\begin{quote}Scan for the first bit that is a 0 or a 1, respectively, and return the position of that bit. Scanning starts with the bit at $starting$\_$bit$ and proceeds towards the more significant bits. If no bit of the specified value is found then ULONG\_MAX is returned.\end{quote}

\begin{lstlisting}
void Z_setbit(Z_t res, unsigned long bit_index)%\gmp%
\end{lstlisting}
\begin{quote}Set the bit with the given index, in $res$.\end{quote}

\begin{lstlisting}
void Z_clrbit(Z_t res, unsigned long bit_index)%\gmp%
\end{lstlisting}
\begin{quote}Clear the bit with the given index, in $res$.\end{quote}

\begin{lstlisting}
void Z_combit(Z_t res, unsigned long bit_index)%\gmp%
\end{lstlisting}
\begin{quote}Complement the bit with the given index, in $res$.\end{quote}

\begin{lstlisting}
int Z_tstbit(Z_t op, unsigned long bit_index)%\gmp%
\end{lstlisting}
\begin{quote}Return $0$ or $1$ according to the value of the bit with the given index in $op$.\end{quote}

\subsection{Input and Output Functions}
The following functions input and output \textbf{Z\_t}'s to files (streams). Replacing the stream pointer with NULL will send the output to \textbf{stdio} and get input from \textbf{stdio}.

\begin{lstlisting}
size_t Z_out_str(FILE *stream, int base, Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Outputs $op$ on the stream specified, as a string of digits in the given base, which must be from 2 to 36. The return value is the number of bytes written, or zero if an error occurs.\end{quote}

\begin{lstlisting}
size_t Z_inp_str(Z_t res, FILE *stream, int base)%\gmp%
\end{lstlisting}
\begin{quote}Input a string of digits in the given base, which must be from 2 to 62, from the given stream, into $res$. The return value will be the number of bytes read, or zero if an error occurs. If base is not given then leading digits are used to determine the base: $0x$ or $0X$ for hexadecimal, $0b$ and $0B$ for binary, $0$ for octal and if no leading digits are given, the base is assumed to be decimal. For bases up to 36, case is ignored. After base 36 upper case letters are used first, then lower case letters.\end{quote}

\begin{lstlisting}
size_t Z_out_raw(FILE *stream, Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Output $op$ on the given stream in raw binary format. Firstly 4 bytes of size information are written, which gives the number of bytes of limbs that follow. Both the size and limbs are written in big-endian format (most significant first). The return value will be the number of bytes written, or zero if an error occurred.\end{quote}

\begin{lstlisting}
size_t Z_inp_raw(Z_t res, FILE *stream)%\gmp%
\end{lstlisting}
\begin{quote}Read $res$ from a stream in the raw binary format written by \textbf{Z\_out\_raw}. Returns the number of bytes read, or zero if an error occurred.\end{quote}

\begin{lstlisting}
void Z_urandomb(Z_t res, unsigned long n)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to a uniformly distributed random number in the range 0 to $2^n-1$, inclusive.\end{quote}

\begin{lstlisting}
void Z_urandomm(Z_t res, Z_t n)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to a uniformly distributed random number in the range 0 to $n-1$ inclusive.\end{quote}

\begin{lstlisting}
void Z_rrandomb(Z_t res, unsigned long n)%\gmp%
\end{lstlisting}
\begin{quote}Sets $res$ to a random number in the range 0 to $2^n-1$ inclusive with long strings of zeroes and ones in its binary representation. Such numbers have proven to be useful in testing corner cases in code.\end{quote}

\subsection{Import and Export Functions}
\begin{lstlisting}
void Z_import(Z_t rop, size_t count, int order, int size,%\gmp%
       int endian, size_t nails, const void *op)
\end{lstlisting}
\begin{quote}Imports raw bytes of limb data from the array $op$ to the integer $rop$.

$count$ words each with $size$ bytes are read. If $order$ is 1 they are stored with the most significant word first, and if $order$ is -1, they are assumed to be stored with the least significant word first. Endian can be 1 or -1 to specify whether within each word the most significant or least significant byte comes first. Setting endian to 0 specifies that the native endianness of the CPU should be used. The nails feature is described in the GMP manual and is experimental. One should set $nails$ to zero if this feature is not being used.

The data in $op$ should specify a positive integer, i.e. have no sign information.\end{quote}

\begin{lstlisting}
void* Z_export(void *rop, size_t *countp, int order, int size,%\gmp% 
      int endian, size_t nails, Z_t op)
\end{lstlisting}
\begin{quote}Exports a \textbf{Z\_t} $op$ to an array of bytes. The meanings of $order$, $size$, $endian$ and $nails$ are described in the previous function. After calling, $countp$ will contain the number of bytes written, unless $countp$ is set to NULL, in which case the count will be discarded. 

The array $rop$ must have sufficient space to store the output bytes, unless $rop$ is set to NULL, in which case space is allocated by GMP. In either case a pointer is returned by the function to the location of the array of output bytes.

If $op$ is zero, no space will be allocated for $rop$, nothing will be written and $countp$ will be set to zero.

This function only outputs the absolute value of $op$, and its sign is ignored.\end{quote}

\subsection{Miscellaneous Functions}
\begin{lstlisting}
int Z_fits_ulong_p(Z_t op)%\gmp%
int Z_fits_slong_p(Z_t op)%\gmp%
int Z_fits_uint_p(Z_t op)%\gmp%
int Z_fits_sint_p(Z_t op)%\gmp%
int Z_fits_ushort_p(Z_t op)%\gmp%
int Z_fits_sshort_p(Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Returns non-zero if $op$ fits into an \textbf{unsigned long}, \textbf{signed long}, \textbf{unsigned int}, \textbf{signed int}, \textbf{unsigned short} or \textbf{signed short} respectively, and returns zero otherwise.\end{quote}

\begin{lstlisting}
int Z_odd_p(Z_t op)%\gmp%
int Z_even_p(Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Return non-zero if $op$ is odd or even respectively, otherwise return zero.\end{quote}

\begin{lstlisting}
size_t Z_sizeinbase(Z_t op, int base)%\gmp%
\end{lstlisting}
\begin{quote}Return the number of digits of $op$ in the given base. If $base$ is a power of 2 the result is exact, otherwise the result may be either exact or one too large. The base may be from 2 to 62. The sign is ignored and if $op$ is 0 the return value is always 1.\end{quote}

\begin{lstlisting}
Z_size(Z_t op)%\gmp%
\end{lstlisting}
\begin{quote}Return the size of (the absolute value of) $op$ in limbs. If $op$ is zero, the return value will be zero.\end{quote}

\subsection{Algorithms}
The modular inversion for \textbf{unsigned long}s is computed using the extended GCD algorithm.

The modular square root is computed using the Tonelli-Shanks algorithm.

At this stage we do not provide asymptotically fast algorithms for computation of GCD's and modular square roots.

All other algorithms are either standard, or in the case of the [GMP] functions, descriptions can be found in the GMP documentation.

\end{document}
